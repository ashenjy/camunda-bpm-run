# Camunda Spring Boot Application
Spring Boot Application using [Camunda](http://docs.camunda.org).

This project has been generated by the Maven archetype
[camunda-archetype-spring-boot-7.16.0](https://docs.camunda.org/manual/latest/user-guide/process-applications/maven-archetypes/).

# Integrating Spring Security with Camunda
https://github.com/camunda-consulting/camunda-7-code-examples/tree/master/snippets/springboot-security-sso

## How does it work?

## How to use it?

## Camunda Spring Security For WebApp and REST API
We need acutally 3 servlet filters:

1. The Spring security filter chain
2. ContainerBasedAuthenticationFilter (from `org.camunda.bpm.webapp.impl.security.auth`)
3. ProcessEngineAuthenticationFilter (from `org.camunda.bpm.engine.rest.security.auth`)

The Spring security filter chain is responsible for authentication on the level of the Spring Boot application. It writes the authentication result to the general Spring SecurityContext, the Camunda engine does not know about it.

The second and third filter are responsible for writing the authentication to the Camunda engine. If there is no authentication written to the engine, the engine won’t check authorization.

- The `ContainerBasedAuthenticationFilter` only applies to APIs belonging to the web apps (routes starting with /app or /api),
- The`ProcessEngineAuthenticationFilter` only applies to the REST API.

Except applying to different URLs, the second and third filter work pretty similar. Both expect an authenciation provider as init parameter.This means you have to specify a class implementing `org.camunda.bpm.engine.rest.security.auth.AuthenticationProvider`. In this class you have to construct a `org.camunda.bpm.engine.rest.security.auth.AuthenticationResult`.

In short, the AuthenticationProvider is responsible for translating the Spring SecurityContext to a Camunda authentication, thus enabling authorization for the Camunda engine.

### Unit Test
You can run the JUnit test [ProcessTest](src/test/java/com/cn/camunda/ProcessTest.java) in your IDE or using:

```bash
mvn clean test
```

### Running the application
You can also build and run the process application with Spring Boot.

#### Manually
1. Build the application using:

```bash
mvn clean package
```
2. Run the *.jar file from the `target` directory using:

```bash
java -jar target/bpm-run.jar
```

For a faster 1-click (re-)deployment see the alternatives below.

#### Maven Spring Boot Plugin
1. Build and deploy the process application using:

```bash
mvn clean package spring-boot:run
```

#### Your Java IDE
1. Run the project as a Java application in your IDE using CamundaApplication as the main class.

### Run and Inspect with Tasklist and Cockpit
Once you deployed the application you can run it using
[Camunda Tasklist](http://docs.camunda.org/latest/guides/user-guide/#tasklist)
and inspect it using
[Camunda Cockpit](http://docs.camunda.org/latest/guides/user-guide/#cockpit).

## Environment Restrictions
Built and tested against Camunda Platform version 7.16.0.


# Integrating Spring Security with Camunda
Overview

This project showcases the integration of Spring Security with Camunda, so one can create a SSO solution based on Spring Security and the Camunda Spring Boot starter.

The main idea is to offload authentication to Spring Security which then makes it easy to plug in any authentication mechanism. Spring Security offers different ways of achieving that:

Option 1: Provide a custom Spring Security AuthenticationProvider which takes care of the whole authentication procedure. In that way, authentication could be done in any (proprietary) Camunda specific way. This approach is not in scope of this showcase.

Option 2: Use any given Identity Management solution (e.g. keycloak, auth0, ...) and integrate it with Spring Security, then pass the authentication on to Camunda using Camunda's AuthenticationFilter. Depending on what one needs to secure, one needs to add a stateless filter for the REST API (similar to ProcessEngineAuthenticationFilter, see here ) or a session based one for the web apps. For the latter, Camunda 7.9 introduced the ContainerBasedAuthenticationFilter that can be used in combination with a custom Camunda AuthenticationProvider.

We also need to make sure that the existing AuthenticationFilter that is already used by the Web Apps does not interfere with our custom one. That means our filter should be first in the order, so that the existing one can serve as a fallback. Since the existing filter only reads auth info from the session, there should be no harm in leaving it in place.

If one needs to use IdentityService APIs or wants to see actual Users and Groups show up in Cockpit, a custom IdentityProvider needs to be implemented as well.

Another example of how to use external authentication can be found in the Camunda SSO JBoss Project or in the Keycloak Spring Boot SSO snippet