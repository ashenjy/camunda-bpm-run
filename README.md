# Spring Security Configuration for Camunda Process Application (e.g. Camunda with Custom JWT Auth)

## Tested on versions

* Camunda BPM: 7.16
* Spring Boot: 2.5.4

## Goal

Use default Spring Boot security with Custom JWT Authentication and provide authenticated access to Camunda WebApps and
Camunda REST.

## Principle

Uses `ContainerBasedAuthenticationProvider` and default Spring Boot security configuration.

## Features



## Required configuration


## Paths and expected responses.

* http://localhost:8181/hello will retrieve protected information and will fail (401) if no token is provided in the request.
* http://localhost:8181/ will redirect to http://localhost:8181/camunda/app/
* http://localhost:8181/camunda/app/* will enforce the HTTP Basic Auth login and redirect back to the webapps (http://localhost:8181/camunda/app/welcome/).
* http://localhost:8181/engine-rest/engine will retrieve the name of the camunda engines initialized ("default") and will fail (401) if no token is provided in the request.


# Camunda Spring Boot Application
This project has been generated by the Maven archetype
[camunda-archetype-spring-boot-7.16.0](https://docs.camunda.org/manual/latest/user-guide/process-applications/maven-archetypes/).


## Camunda Spring Security For WebApp and REST API
We need 3 servlet filters:
1. The Spring security filter chain
2. ContainerBasedAuthenticationFilter (from `org.camunda.bpm.webapp.impl.security.auth`)
3. ProcessEngineAuthenticationFilter (from `org.camunda.bpm.engine.rest.security.auth`)

The Spring security filter chain is responsible for authentication on the level of the Spring Boot application. It writes the authentication result to the general Spring SecurityContext, the Camunda engine does not know about it.

The second and third filter are responsible for writing the authentication to the Camunda engine. If there is no authentication written to the engine, the engine won’t check authorization.

- The `ContainerBasedAuthenticationFilter` only applies to APIs belonging to the web apps (routes starting with /app or /api),
- The`ProcessEngineAuthenticationFilter` only applies to the REST API.

Except applying to different URLs, the second and third filter work pretty similar. Both expect an authenciation provider as init parameter.This means you have to specify a class implementing `org.camunda.bpm.engine.rest.security.auth.AuthenticationProvider`. In this class you have to construct a `org.camunda.bpm.engine.rest.security.auth.AuthenticationResult`.

In short, the AuthenticationProvider is responsible for translating the Spring SecurityContext to a Camunda authentication, thus enabling authorization for the Camunda engine.


## Environment Restrictions
Built and tested against Camunda Platform version 7.16.0.


# Integrating Spring Security with Camunda
Overview

This project showcases the integration of Spring Security with Camunda, so one can create a SSO solution based on Spring Security and the Camunda Spring Boot starter.

The main idea is to offload authentication to Spring Security which then makes it easy to plug in any authentication mechanism. Spring Security offers different ways of achieving that:

Option 1: Provide a custom Spring Security AuthenticationProvider which takes care of the whole authentication procedure. In that way, authentication could be done in any (proprietary) Camunda specific way. This approach is not in scope of this showcase.

Option 2: Use any given Identity Management solution (e.g. keycloak, auth0, ...) and integrate it with Spring Security, then pass the authentication on to Camunda using Camunda's AuthenticationFilter. Depending on what one needs to secure, one needs to add a stateless filter for the REST API (similar to ProcessEngineAuthenticationFilter, see here ) or a session based one for the web apps. For the latter, Camunda 7.9 introduced the ContainerBasedAuthenticationFilter that can be used in combination with a custom Camunda AuthenticationProvider.

We also need to make sure that the existing AuthenticationFilter that is already used by the Web Apps does not interfere with our custom one. That means our filter should be first in the order, so that the existing one can serve as a fallback. Since the existing filter only reads auth info from the session, there should be no harm in leaving it in place.

If one needs to use IdentityService APIs or wants to see actual Users and Groups show up in Cockpit, a custom IdentityProvider needs to be implemented as well.

Another example of how to use external authentication can be found in the Camunda SSO JBoss Project or in the Keycloak Spring Boot SSO snippet